async function translateText(text: string, from: string, to: string): Promise<string> {
  const original = (text ?? "").trim();
  if (!original) return "";

  // Split into safe segments but keep structure
  const segments = splitIntoSegments(original, 900); // a bit larger to preserve formatting
  if (segments.length === 1) {
    return translateOne(segments[0], from, to);
  }

  // Ask model to keep markers so we can reconstruct without losing parts
  const marked = segments
    .map((s, i) => `[[SEG:${i + 1}]]\n${s}\n[[/SEG]]`)
    .join("\n\n");

  const prompt =
    `You are a professional translator.\n` +
    `Translate from ${from} to ${to}.\n` +
    `Rules:\n` +
    `- Translate EVERYTHING inside each segment.\n` +
    `- Keep [[SEG:n]] and [[/SEG]] markers EXACTLY.\n` +
    `- Preserve line breaks, bullet points, and headings.\n` +
    `- Do NOT summarise. Do NOT omit anything.\n` +
    `- Keep names as-is.\n\n` +
    `TEXT:\n${marked}\n`;

  const out = await llmTranslate(prompt);

  const rebuilt = rebuildFromSegments(out, segments.length);
  if (rebuilt) {
    // If it looks like large parts stayed in English, retry smaller-per-segment
    if (looksUntranslated(original, rebuilt, to)) {
      return translateBySegmentFallback(segments, from, to);
    }
    return rebuilt;
  }

  // If markers got lost, fall back to per-segment translation
  return translateBySegmentFallback(segments, from, to);
}

/** Smaller / safer single segment translation */
async function translateOne(text: string, from: string, to: string): Promise<string> {
  const prompt =
    `Translate from ${from} to ${to}.\n` +
    `Rules: translate everything, preserve formatting, do not summarise.\n\n` +
    text;
  return (await llmTranslate(prompt)).trim();
}

function splitIntoSegments(input: string, maxChars: number): string[] {
  // Keep paragraphs, but break very large ones
  const paras = input.split(/\n{2,}/);
  const out: string[] = [];
  let buf = "";

  const flush = () => {
    const t = buf.trim();
    if (t) out.push(t);
    buf = "";
  };

  for (const p of paras) {
    const chunk = p.trim();
    if (!chunk) continue;

    if ((buf + "\n\n" + chunk).trim().length <= maxChars) {
      buf = buf ? `${buf}\n\n${chunk}` : chunk;
      continue;
    }

    flush();

    if (chunk.length <= maxChars) {
      out.push(chunk);
      continue;
    }

    // Hard-break long paragraphs by lines
    const lines = chunk.split("\n");
    let b = "";
    for (const line of lines) {
      if ((b + "\n" + line).trim().length <= maxChars) {
        b = b ? `${b}\n${line}` : line;
      } else {
        if (b.trim()) out.push(b.trim());
        b = line;
      }
    }
    if (b.trim()) out.push(b.trim());
  }

  flush();
  return out.length ? out : [input];
}

function rebuildFromSegments(output: string, expectedCount: number): string | null {
  const map = new Map<number, string>();
  const re = /\[\[SEG:(\d+)\]\]([\s\S]*?)\[\[\/SEG\]\]/g;
  let m: RegExpExecArray | null;
  while ((m = re.exec(output)) !== null) {
    const idx = Number(m[1]);
    const body = (m[2] ?? "").trim();
    if (idx && body) map.set(idx, body);
  }

  if (map.size !== expectedCount) return null;

  const parts: string[] = [];
  for (let i = 1; i <= expectedCount; i++) {
    const v = map.get(i);
    if (!v) return null;
    parts.push(v);
  }
  return parts.join("\n\n").trim();
}

function looksUntranslated(input: string, output: string, targetLang: string): boolean {
  // If translating to English, ignore this check
  if (/^en/i.test(targetLang)) return false;

  // Heuristic: if too many long words appear unchanged, likely not translated fully
  const words = (s: string) =>
    (s.toLowerCase().match(/[a-z]{5,}/g) ?? []).slice(0, 300);

  const a = new Set(words(input));
  const b = words(output);

  if (b.length < 20) return false;

  let same = 0;
  for (const w of b) if (a.has(w)) same++;

  const ratio = same / b.length;
  return ratio > 0.55; // tune: >55% shared long words = suspicious
}

async function translateBySegmentFallback(segments: string[], from: string, to: string): Promise<string> {
  const results: string[] = [];
  for (const s of segments) {
    results.push(await translateOne(s, from, to));
  }
  return results.join("\n\n").trim();
}
