name: Apply ZIP package to repo (API, no git)

on:
  workflow_dispatch:
    inputs:
      zip_path:
        description: "ZIP path in repo (e.g. imports/smart-tool-admin-playbook.zip)"
        required: true
        default: "imports/smart-tool-admin-playbook.zip"
      target_branch:
        description: "Branch to apply to"
        required: true
        default: "main"

permissions:
  contents: write

jobs:
  apply_zip_api:
    runs-on: ubuntu-latest

    steps:
      - name: Download ZIP from repo
        uses: actions/github-script@v7
        env:
          ZIP_PATH: ${{ inputs.zip_path }}
        with:
          github-token: ${{ secrets.REPO_PAT }}
          script: |
            const zipPath = process.env.ZIP_PATH;
            if (!zipPath) {
              core.setFailed("ZIP_PATH env is empty. Did workflow_dispatch inputs pass through?");
              return;
            }

            const { owner, repo } = context.repo;

            const res = await github.rest.repos.getContent({ owner, repo, path: zipPath });
            if (!res?.data?.download_url) {
              core.setFailed(`No download_url for ${zipPath}. Is it committed to the repo?`);
              return;
            }

            core.info(`Downloading: ${res.data.download_url}`);
            const fs = require('fs');
            const https = require('https');

            await new Promise((resolve, reject) => {
              https.get(res.data.download_url, (r) => {
                if (r.statusCode !== 200) return reject(new Error(`HTTP ${r.statusCode}`));
                const out = fs.createWriteStream('/tmp/apply.zip');
                r.pipe(out);
                out.on('finish', () => out.close(resolve));
              }).on('error', reject);
            });

            core.info('Saved /tmp/apply.zip');

      - name: Unzip payload
        shell: bash
        run: |
          set -euo pipefail
          rm -rf /tmp/payload
          mkdir -p /tmp/payload
          unzip -q /tmp/apply.zip -d /tmp/payload
          echo "Payload root listing:"
          ls -la /tmp/payload

          COUNT_DIR=$(find /tmp/payload -mindepth 1 -maxdepth 1 -type d | wc -l | tr -d ' ')
          COUNT_FILES=$(find /tmp/payload -mindepth 1 -maxdepth 1 -type f | wc -l | tr -d ' ')
          if [ "$COUNT_DIR" -eq 1 ] && [ "$COUNT_FILES" -eq 0 ]; then
            echo "ROOT_DIR=$(find /tmp/payload -mindepth 1 -maxdepth 1 -type d | head -n 1)" >> "$GITHUB_ENV"
          else
            echo "ROOT_DIR=/tmp/payload" >> "$GITHUB_ENV"
          fi

          echo "ROOT_DIR env file contents:"
          cat "$GITHUB_ENV"

      - name: Apply payload via GitHub API commit (no git)
        uses: actions/github-script@v7
        env:
          ROOT_DIR: ${{ env.ROOT_DIR }}
          TARGET_BRANCH: ${{ inputs.target_branch }}
          ZIP_PATH: ${{ inputs.zip_path }}
        with:
          github-token: ${{ secrets.REPO_PAT }}
          script: |
            const fs = require('fs');
            const path = require('path');

            const { owner, repo } = context.repo;
            const branch = process.env.TARGET_BRANCH;
            const rootDir = process.env.ROOT_DIR;
            const zipPath = process.env.ZIP_PATH;

            if (!branch) { core.setFailed("TARGET_BRANCH missing"); return; }
            if (!rootDir) { core.setFailed("ROOT_DIR missing"); return; }

            function walk(dir, baseDir, out=[]) {
              for (const name of fs.readdirSync(dir)) {
                const full = path.join(dir, name);
                const rel = path.relative(baseDir, full).replace(/\\/g, '/');
                const stat = fs.statSync(full);
                if (stat.isDirectory()) {
                  if (rel === 'node_modules' || rel.startsWith('node_modules/')) continue;
                  out = walk(full, baseDir, out);
                } else {
                  out.push({ full, rel });
                }
              }
              return out;
            }

            const ref = await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` });
            const baseCommitSha = ref.data.object.sha;
            const baseCommit = await github.rest.git.getCommit({ owner, repo, commit_sha: baseCommitSha });
            const baseTreeSha = baseCommit.data.tree.sha;

            const existing = await github.rest.git.getTree({ owner, repo, tree_sha: baseTreeSha, recursive: "1" });
            const existingPaths = new Set(existing.data.tree.filter(t => t.type === 'blob').map(t => t.path));

            const files = walk(rootDir, rootDir);

            // Basic sanity: this looks like your Vite+React repo
            if (!files.some(f => f.rel === 'package.json') || !files.some(f => f.rel === 'src/index.css')) {
              core.setFailed("Payload doesn't look like the app repo root. Wrong ZIP contents?");
              return;
            }

            const newPaths = new Set(files.map(f => f.rel));

            // Protect your imports folder and the ZIP itself
            function isProtected(p) {
              return p === 'imports' || p.startsWith('imports/') || p === zipPath;
            }

            const tree = [];

            // Create blobs for payload files
            for (const f of files) {
              const content = fs.readFileSync(f.full);
              const blob = await github.rest.git.createBlob({
                owner, repo,
                content: content.toString('base64'),
                encoding: 'base64'
              });
              tree.push({ path: f.rel, mode: '100644', type: 'blob', sha: blob.data.sha });
            }

            // Deletions: remove old files not present in payload (excluding imports/**)
            for (const p of existingPaths) {
              if (isProtected(p)) continue;
              if (!newPaths.has(p)) tree.push({ path: p, mode: '100644', type: 'blob', sha: null });
            }

            const newTree = await github.rest.git.createTree({
              owner, repo,
              base_tree: baseTreeSha,
              tree
            });

            const commit = await github.rest.git.createCommit({
              owner, repo,
              message: `Apply ZIP payload (${zipPath || 'zip'})`,
              tree: newTree.data.sha,
              parents: [baseCommitSha]
            });

            await github.rest.git.updateRef({
              owner, repo,
              ref: `heads/${branch}`,
              sha: commit.data.sha,
              force: false
            });

            core.info(`Committed ${commit.data.sha} to ${branch}`);
