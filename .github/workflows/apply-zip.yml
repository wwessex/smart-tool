name: Apply ZIP package to repo (API, no git)

on:
  workflow_dispatch:
    inputs:
      zip_path:
        description: "ZIP path in repo (e.g. imports/smart-tool-admin-playbook.zip)"
        required: true
        default: "imports/smart-tool-admin-playbook.zip"
      target_branch:
        description: "Branch to apply to"
        required: true
        default: "main"

permissions:
  contents: write

jobs:
  apply_zip_api:
    runs-on: ubuntu-latest

    steps:
      - name: Download ZIP from repo
        uses: actions/github-script@v7
        with:
          script: |
            const path = core.getInput('zip_path');
            const { owner, repo } = context.repo;

            const res = await github.rest.repos.getContent({ owner, repo, path });
            if (!res?.data?.download_url) {
              core.setFailed(`No download_url for ${path}. Is it committed to the repo?`);
              return;
            }

            core.info(`Downloading: ${res.data.download_url}`);
            const fs = require('fs');
            const https = require('https');

            await new Promise((resolve, reject) => {
              https.get(res.data.download_url, (r) => {
                if (r.statusCode !== 200) return reject(new Error(`HTTP ${r.statusCode}`));
                const out = fs.createWriteStream('/tmp/apply.zip');
                r.pipe(out);
                out.on('finish', () => out.close(resolve));
              }).on('error', reject);
            });

            core.info('Saved /tmp/apply.zip');

      - name: Unzip payload
        shell: bash
        run: |
          set -euo pipefail
          rm -rf /tmp/payload
          mkdir -p /tmp/payload
          unzip -q /tmp/apply.zip -d /tmp/payload
          echo "Payload root listing:"
          ls -la /tmp/payload

          # If single top-level folder, flatten detection for later script
          COUNT_DIR=$(find /tmp/payload -mindepth 1 -maxdepth 1 -type d | wc -l | tr -d ' ')
          COUNT_FILES=$(find /tmp/payload -mindepth 1 -maxdepth 1 -type f | wc -l | tr -d ' ')
          if [ "$COUNT_DIR" -eq 1 ] && [ "$COUNT_FILES" -eq 0 ]; then
            echo "ROOT_DIR=$(find /tmp/payload -mindepth 1 -maxdepth 1 -type d | head -n 1)" >> $GITHUB_ENV
          else
            echo "ROOT_DIR=/tmp/payload" >> $GITHUB_ENV
          fi
          echo "Using ROOT_DIR=$ROOT_DIR"

      - name: Apply payload via GitHub API commit (no git)
        uses: actions/github-script@v7
        env:
          ROOT_DIR: ${{ env.ROOT_DIR }}
          TARGET_BRANCH: ${{ inputs.target_branch }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const { owner, repo } = context.repo;
            const branch = process.env.TARGET_BRANCH;
            const rootDir = process.env.ROOT_DIR;

            function walk(dir, baseDir, out=[]) {
              for (const name of fs.readdirSync(dir)) {
                const full = path.join(dir, name);
                const rel = path.relative(baseDir, full).replace(/\\/g, '/');
                const stat = fs.statSync(full);
                if (stat.isDirectory()) {
                  if (rel === 'node_modules' || rel.startsWith('node_modules/')) continue;
                  out = walk(full, baseDir, out);
                } else {
                  out.push({ full, rel });
                }
              }
              return out;
            }

            // Get current branch ref -> commit -> tree
            const ref = await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` });
            const baseCommitSha = ref.data.object.sha;
            const baseCommit = await github.rest.git.getCommit({ owner, repo, commit_sha: baseCommitSha });
            const baseTreeSha = baseCommit.data.tree.sha;

            // Get existing tree recursively (for deletions)
            const existing = await github.rest.git.getTree({ owner, repo, tree_sha: baseTreeSha, recursive: "1" });
            const existingPaths = new Set(
              existing.data.tree
                .filter(t => t.type === 'blob')
                .map(t => t.path)
            );

            // Build new blobs + tree entries from ZIP payload
            const files = walk(rootDir, rootDir);
            if (!files.some(f => f.rel === 'package.json')) {
              core.setFailed('Payload does not look like a repo root (package.json missing). Wrong ZIP?');
              return;
            }

            const newPaths = new Set(files.map(f => f.rel));

            // Keep imports/** from existing (do not delete your ZIP store)
            function isProtected(p) {
              return p === 'imports' || p.startsWith('imports/');
            }

            const tree = [];

            // Create blobs for all payload files
            for (const f of files) {
              const content = fs.readFileSync(f.full);
              const blob = await github.rest.git.createBlob({
                owner, repo,
                content: content.toString('base64'),
                encoding: 'base64'
              });
              tree.push({
                path: f.rel,
                mode: '100644',
                type: 'blob',
                sha: blob.data.sha
              });
            }

            // Deletions: remove existing files not in payload, except protected imports/**
            for (const p of existingPaths) {
              if (isProtected(p)) continue;
              if (!newPaths.has(p)) {
                tree.push({ path: p, mode: '100644', type: 'blob', sha: null });
              }
            }

            // Create new tree, commit, update ref
            const newTree = await github.rest.git.createTree({
              owner, repo,
              base_tree: baseTreeSha,
              tree
            });

            const commit = await github.rest.git.createCommit({
              owner, repo,
              message: `Apply ZIP payload (${path.basename(core.getInput('zip_path'))})`,
              tree: newTree.data.sha,
              parents: [baseCommitSha]
            });

            await github.rest.git.updateRef({
              owner, repo,
              ref: `heads/${branch}`,
              sha: commit.data.sha,
              force: false
            });

            core.info(`Committed ${commit.data.sha} to ${branch}`);
